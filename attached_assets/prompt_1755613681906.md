Awesome—here’s a **developer-ready, copy-pasteable build guide** for a **single codebase** that ships as both a **Web app (PWA)** and a **Desktop app (Electron)**, using **MERN + client-side STT + server-side semantic matching**.

I’ve written this so a Replit AI Agent can execute it step-by-step without clarifications.

---

# Full Build Guide: Digital Assignment App (MERN + PWA + Electron + NLP)

## 0) Tech Stack (lock these in)

* **Frontend:** React + Vite, TypeScript, Tailwind CSS, React Router
* **PWA:** Vite PWA plugin
* **Voice-to-Text (client-side):** Web Speech API (default) with optional Whisper.js toggle
* **Desktop:** Electron + electron-builder (single codebase wrapper)
* **Backend:** Node.js (Express), TypeScript, Zod (validation)
* **DB:** MongoDB (Atlas)
* **Auth:** JWT (httpOnly cookie) + bcrypt
* **NLP Similarity (server-side):** `@xenova/transformers` (all-MiniLM-L6-v2) → cosine similarity
* **Proctoring (light):** copy/paste/selection disable, tab change logging, optional webcam snapshot (Electron only), mic background-voice flag
* **State:** React Query
* **Testing:** Vitest (FE), Jest (BE)
* **Lint/Format:** ESLint + Prettier
* **Dev UX:** concurrently + turbo (optional)
* **CI:** GitHub Actions (optional)

---

## 1) Monorepo Layout

```
digital-assignment/
├─ apps/
│  ├─ web/                 # React + Vite + PWA
│  └─ desktop/             # Electron wrapper loading apps/web build
├─ packages/
│  ├─ api/                 # Express server (TypeScript)
│  └─ shared/              # Shared TS types, validation schemas, utilities
├─ .env.example
├─ package.json            # workspace root (pnpm or npm)
├─ turbo.json              # optional speed-up
└─ README.md
```

**Root `package.json` (workspaces):**

```json
{
  "name": "digital-assignment",
  "private": true,
  "workspaces": ["apps/*", "packages/*"],
  "scripts": {
    "dev:web": "pnpm -C apps/web dev",
    "build:web": "pnpm -C apps/web build",
    "preview:web": "pnpm -C apps/web preview",
    "dev:api": "pnpm -C packages/api dev",
    "build:api": "pnpm -C packages/api build && pnpm -C packages/api start",
    "dev:desktop": "pnpm -C apps/desktop dev",
    "build:desktop": "pnpm -C apps/desktop build",
    "dev": "concurrently -n WEB,API -c green,cyan \"pnpm dev:web\" \"pnpm dev:api\"",
    "lint": "eslint . --ext .ts,.tsx",
    "format": "prettier -w ."
  },
  "devDependencies": {
    "concurrently": "^9.0.0",
    "eslint": "^9.8.0",
    "prettier": "^3.3.3"
  },
  "packageManager": "pnpm@9.7.0"
}
```

> Replit: Use **pnpm** or **npm** consistently. If npm is preferred, replace `pnpm -C` with `npm --workspace`.

---

## 2) Environment Variables (`.env`)

Copy `.env.example` → `.env` in root and API package.

```
# Mongo
MONGODB_URI=<your MongoDB Atlas URI>
MONGODB_DB=assignment_app

# Auth
JWT_SECRET=<random-long-secret>
JWT_EXPIRES=7d

# Server
PORT=4000
CORS_ORIGIN=http://localhost:5173

# Similarity caching (optional)
MODEL_NAME=Xenova/all-MiniLM-L6-v2
```

---

## 3) Shared Types & Schemas (`packages/shared`)

Install:

```
pnpm -C packages/shared init -y
pnpm -C packages/shared add zod
```

`packages/shared/src/types.ts`

```ts
export type Role = 'teacher' | 'student';

export interface User {
  _id: string;
  name: string;
  email: string;
  role: Role;
  createdAt: string;
}

export interface Assignment {
  _id: string;
  code: string;                 // unique code
  title: string;
  questions: { id: string; text: string; answerKey: string }[];
  mode: 'voice' | 'voice_text';
  teacherId: string;
  createdAt: string;
}

export interface Submission {
  _id: string;
  assignmentId: string;
  studentId: string;
  answers: { questionId: string; text: string; sttMeta?: any }[];
  scores: { questionId: string; similarity: number; awarded: number }[];
  totalAwarded: number;
  createdAt: string;
}
```

`packages/shared/src/schemas.ts`

```ts
import { z } from 'zod';

export const RegisterSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  password: z.string().min(6),
  role: z.enum(['teacher','student'])
});

export const LoginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(6)
});

export const CreateAssignmentSchema = z.object({
  title: z.string().min(3),
  mode: z.enum(['voice','voice_text']),
  questions: z.array(z.object({
    id: z.string(),
    text: z.string().min(3),
    answerKey: z.string().min(1)
  }))
});

export const SubmitAnswersSchema = z.object({
  assignmentCode: z.string().min(4),
  answers: z.array(z.object({
    questionId: z.string(),
    text: z.string().min(1),
    sttMeta: z.any().optional()
  }))
});
```

---

## 4) Backend API (`packages/api`)

Install:

```
pnpm -C packages/api init -y
pnpm -C packages/api add express cors cookie-parser bcrypt jsonwebtoken mongoose @xenova/transformers
pnpm -C packages/api add zod
pnpm -C packages/api add ts-node-dev typescript @types/node @types/express @types/cookie-parser @types/jsonwebtoken @types/cors -D
```

`packages/api/tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "CommonJS",
    "rootDir": "src",
    "outDir": "dist",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true
  }
}
```

`packages/api/package.json` scripts:

```json
{
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js"
  }
}
```

**Models (`src/models`)**

```ts
// src/models/User.ts
import { Schema, model } from 'mongoose';
const UserSchema = new Schema({
  name: String,
  email: { type: String, unique: true },
  passHash: String,
  role: { type: String, enum: ['teacher','student'] },
}, { timestamps: true });
export default model('User', UserSchema);

// src/models/Assignment.ts
import { Schema, model } from 'mongoose';
const QuestionSchema = new Schema({
  id: String,
  text: String,
  answerKey: String
});
const AssignmentSchema = new Schema({
  code: { type: String, unique: true },
  title: String,
  mode: { type: String, enum: ['voice','voice_text'] },
  questions: [QuestionSchema],
  teacherId: { type: Schema.Types.ObjectId, ref: 'User' }
}, { timestamps: true });
export default model('Assignment', AssignmentSchema);

// src/models/Submission.ts
import { Schema, model } from 'mongoose';
const AnsSchema = new Schema({
  questionId: String,
  text: String,
  sttMeta: Schema.Types.Mixed
});
const ScoreSchema = new Schema({
  questionId: String,
  similarity: Number,
  awarded: Number
});
const SubmissionSchema = new Schema({
  assignmentId: { type: Schema.Types.ObjectId, ref: 'Assignment' },
  studentId: { type: Schema.Types.ObjectId, ref: 'User' },
  answers: [AnsSchema],
  scores: [ScoreSchema],
  totalAwarded: Number
}, { timestamps: true });
export default model('Submission', SubmissionSchema);
```

**Bootstrap `src/index.ts`**

```ts
import express from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import mongoose from 'mongoose';
import authRouter from './routes/auth';
import assignmentRouter from './routes/assignment';
import submissionRouter from './routes/submission';

const app = express();
app.use(express.json({ limit: '2mb' }));
app.use(cookieParser());
app.use(cors({ origin: process.env.CORS_ORIGIN || true, credentials: true }));

mongoose.connect(process.env.MONGODB_URI!, { dbName: process.env.MONGODB_DB });

app.get('/health', (_, res) => res.json({ ok: true }));
app.use('/auth', authRouter);
app.use('/assignments', assignmentRouter);
app.use('/submissions', submissionRouter);

const PORT = process.env.PORT || 4000;
app.listen(PORT, () => console.log('API listening on', PORT));
```

**Auth middleware `src/middleware/auth.ts`**

```ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

export interface AuthedRequest extends Request {
  user?: { id: string; role: 'teacher'|'student' };
}

export function requireAuth(req: AuthedRequest, res: Response, next: NextFunction) {
  const token = req.cookies?.token;
  if (!token) return res.status(401).json({ error: 'unauthorized' });
  try {
    req.user = jwt.verify(token, process.env.JWT_SECRET!) as any;
    next();
  } catch {
    res.status(401).json({ error: 'invalid_token' });
  }
}

export function requireRole(role: 'teacher'|'student') {
  return (req: AuthedRequest, res: Response, next: NextFunction) => {
    if (req.user?.role !== role) return res.status(403).json({ error: 'forbidden' });
    next();
  };
}
```

**Auth routes `src/routes/auth.ts`**

```ts
import { Router } from 'express';
import { z } from 'zod';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import User from '../models/User';
import { RegisterSchema, LoginSchema } from '../../../packages/shared/src/schemas';

const r = Router();

r.post('/register', async (req, res) => {
  const parsed = RegisterSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json(parsed.error);
  const { name, email, password, role } = parsed.data;
  const exists = await User.findOne({ email });
  if (exists) return res.status(409).json({ error: 'email_in_use' });
  const passHash = await bcrypt.hash(password, 10);
  const user = await User.create({ name, email, passHash, role });
  res.json({ id: user._id });
});

r.post('/login', async (req, res) => {
  const parsed = LoginSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json(parsed.error);
  const { email, password } = parsed.data;
  const user = await User.findOne({ email });
  if (!user) return res.status(401).json({ error: 'invalid' });
  const ok = await bcrypt.compare(password, user.passHash);
  if (!ok) return res.status(401).json({ error: 'invalid' });
  const token = jwt.sign({ id: user._id.toString(), role: user.role }, process.env.JWT_SECRET!, { expiresIn: process.env.JWT_EXPIRES || '7d' });
  res.cookie('token', token, { httpOnly: true, sameSite: 'lax' }).json({ ok: true });
});

r.post('/logout', (req, res) => {
  res.clearCookie('token').json({ ok: true });
});

export default r;
```

**Similarity service `src/services/similarity.ts`**

```ts
import { pipeline } from '@xenova/transformers';

// Lazy singleton
let embedder: any;
export async function getEmbedder() {
  if (!embedder) {
    embedder = await pipeline('feature-extraction', process.env.MODEL_NAME || 'Xenova/all-MiniLM-L6-v2');
  }
  return embedder;
}

function l2norm(v: number[]) {
  return Math.sqrt(v.reduce((s, x) => s + x * x, 0));
}
function cosine(a: number[], b: number[]) {
  const dot = a.reduce((s, x, i) => s + x * b[i], 0);
  return dot / (l2norm(a) * l2norm(b) + 1e-8);
}

export async function similarity(a: string, b: string) {
  const emb = await getEmbedder();
  const [ea] = await emb(a, { pooling: 'mean', normalize: true });
  const [eb] = await emb(b, { pooling: 'mean', normalize: true });
  // Already normalized; cosine is dot
  const sim = ea.reduce((s: number, x: number, i: number) => s + x * eb[i], 0);
  return sim; // 0..1
}
```

**Assignment & Submission routes**

```ts
// src/routes/assignment.ts
import { Router } from 'express';
import { requireAuth, requireRole, AuthedRequest } from '../middleware/auth';
import Assignment from '../models/Assignment';
import { CreateAssignmentSchema } from '../../../packages/shared/src/schemas';

const r = Router();

function genCode() { return Math.random().toString(36).slice(2, 8).toUpperCase(); }

r.post('/', requireAuth, requireRole('teacher'), async (req: AuthedRequest, res) => {
  const parsed = CreateAssignmentSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json(parsed.error);
  const code = genCode();
  const assignment = await Assignment.create({
    ...parsed.data,
    code,
    teacherId: req.user!.id
  });
  res.json({ id: assignment._id, code });
});

r.get('/code/:code', requireAuth, async (req, res) => {
  const a = await Assignment.findOne({ code: req.params.code });
  if (!a) return res.status(404).json({ error: 'not_found' });
  res.json(a);
});

export default r;
```

```ts
// src/routes/submission.ts
import { Router } from 'express';
import { requireAuth, requireRole, AuthedRequest } from '../middleware/auth';
import Submission from '../models/Submission';
import Assignment from '../models/Assignment';
import { SubmitAnswersSchema } from '../../../packages/shared/src/schemas';
import { similarity } from '../services/similarity';

const r = Router();

const THRESHOLD = 0.70; // default; teacher-specific threshold can be added later
const MARKS_PER_QUESTION = 1;

r.post('/', requireAuth, requireRole('student'), async (req: AuthedRequest, res) => {
  const parsed = SubmitAnswersSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json(parsed.error);
  const { assignmentCode, answers } = parsed.data;

  const assignment = await Assignment.findOne({ code: assignmentCode });
  if (!assignment) return res.status(404).json({ error: 'assignment_not_found' });

  // grade
  const scores = await Promise.all(answers.map(async ans => {
    const q = assignment.questions.find(q => q.id === ans.questionId);
    if (!q) return { questionId: ans.questionId, similarity: 0, awarded: 0 };
    const sim = await similarity(ans.text, q.answerKey); // 0..1
    const awarded = sim >= THRESHOLD ? MARKS_PER_QUESTION : 0;
    return { questionId: ans.questionId, similarity: sim, awarded };
  }));
  const totalAwarded = scores.reduce((s, x) => s + x.awarded, 0);

  const submission = await Submission.create({
    assignmentId: assignment._id,
    studentId: req.user!.id,
    answers,
    scores,
    totalAwarded
  });

  res.json({ submissionId: submission._id, scores, totalAwarded });
});

export default r;
```

---

## 5) Frontend Web App (`apps/web`)

Install:

```
pnpm create vite apps/web --template react-ts
pnpm -C apps/web add react-router-dom @tanstack/react-query axios zustand
pnpm -C apps/web add tailwindcss postcss autoprefixer
pnpm -C apps/web dlx tailwindcss init -p
pnpm -C apps/web add @vite-pwa/plugin-pwa
```

**Tailwind setup** (config `content` globs).

**PWA plugin** in `vite.config.ts`:

```ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { VitePWA } from '@vite-pwa/plugin-pwa'

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: 'autoUpdate',
      manifest: { name: 'Digital Assignment', short_name: 'Assignment', start_url: '/', display: 'standalone', icons: [] }
    })
  ],
  server: { port: 5173 }
})
```

**Anti-cheat (web) utilities**

```ts
// src/antiCheat.ts
export function installBasicGuards() {
  const handler = (e: Event) => e.preventDefault();
  document.addEventListener('contextmenu', handler);
  document.addEventListener('copy', handler as any);
  document.addEventListener('cut', handler as any);
  document.addEventListener('paste', handler as any);
  document.addEventListener('selectstart', handler as any);
  window.addEventListener('blur', () => {
    // log tab switch; send beacon
    navigator.sendBeacon('/analytics/focus', JSON.stringify({ at: Date.now(), type: 'blur' }));
  });
}
```

**Client-side STT (default Web Speech API)**

```ts
// src/stt.ts
export function startSTT(onText: (t: string) => void) {
  const SR: any = (window as any).webkitSpeechRecognition || (window as any).SpeechRecognition;
  if (!SR) return { stop: () => {}, supported: false };

  const rec = new SR();
  rec.lang = 'en-US'; // make configurable
  rec.continuous = true;
  rec.interimResults = true;

  let transcript = '';
  rec.onresult = (e: any) => {
    transcript = '';
    for (let i = e.resultIndex; i < e.results.length; i++) {
      transcript += e.results[i][0].transcript;
    }
    onText(transcript);
  };

  rec.start();
  return { stop: () => rec.stop(), supported: true };
}
```

**Answer screen (core UX)**

```tsx
// src/pages/Answer.tsx
import { useEffect, useState } from 'react';
import { startSTT } from '../stt';
import axios from 'axios';

export default function Answer() {
  const [assignment, setAssignment] = useState<any>(null);
  const [code, setCode] = useState('');
  const [running, setRunning] = useState(false);
  const [answers, setAnswers] = useState<Record<string,string>>({});

  async function load() {
    if (!code) return;
    const { data } = await axios.get(`/assignments/code/${code}`, { withCredentials: true, baseURL: import.meta.env.VITE_API_URL });
    setAssignment(data);
  }

  useEffect(() => { if (!assignment) return; /* install anti-cheat */ }, [assignment]);

  function record(qid: string) {
    const stt = startSTT((t) => setAnswers(a => ({ ...a, [qid]: t })));
    setRunning(true);
    return () => { stt.stop(); setRunning(false); };
  }

  async function submit() {
    const formatted = Object.entries(answers).map(([questionId, text]) => ({ questionId, text }));
    const { data } = await axios.post('/submissions', { assignmentCode: code, answers: formatted }, { withCredentials: true, baseURL: import.meta.env.VITE_API_URL });
    alert(`Score: ${data.totalAwarded}`);
  }

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold">Enter Assignment Code</h1>
      <input value={code} onChange={e=>setCode(e.target.value)} className="border p-2"/>
      <button onClick={load} className="ml-2 px-3 py-2 bg-black text-white">Load</button>

      {assignment && (
        <div className="mt-6 space-y-6">
          <h2 className="text-xl font-semibold">{assignment.title}</h2>
          {assignment.questions.map((q: any) => (
            <div key={q.id} className="rounded-xl border p-4">
              <p className="font-medium">{q.text}</p>
              <textarea
                className="mt-2 w-full border p-2"
                rows={4}
                value={answers[q.id] || ''}
                onChange={e=>setAnswers(a=>({ ...a, [q.id]: e.target.value }))}
              />
              <div className="mt-2 flex gap-2">
                <button onClick={record(q.id)} className="px-3 py-2 border">🎙️ Start / Update</button>
              </div>
            </div>
          ))}
          <button onClick={submit} className="px-4 py-2 bg-green-600 text-white rounded">Submit</button>
        </div>
      )}
    </div>
  );
}
```

> For Whisper.js: add a toggle, lazy-load model, and write a `startWhisperWorker()` variant when Web Speech API not supported.

---

## 6) Electron Desktop (`apps/desktop`)

Install:

```
pnpm -C apps/desktop init -y
pnpm -C apps/desktop add electron electron-builder cross-env
```

`apps/desktop/package.json`:

```json
{
  "name": "digital-assignment-desktop",
  "main": "main.js",
  "version": "1.0.0",
  "scripts": {
    "dev": "cross-env VITE_URL=http://localhost:5173 electron .",
    "build": "electron-builder"
  },
  "build": {
    "appId": "com.yourorg.assignment",
    "files": ["main.js", "preload.js", "dist/**"],
    "win": { "target": "nsis" },
    "mac": { "category": "public.app-category.education" },
    "linux": { "target": "AppImage" }
  },
  "devDependencies": {
    "electron": "^31.0.0",
    "electron-builder": "^24.13.3",
    "cross-env": "^7.0.3"
  }
}
```

`apps/desktop/main.js`

```js
const { app, BrowserWindow, session, globalShortcut } = require('electron');
const path = require('path');

function createWindow() {
  const win = new BrowserWindow({
    width: 1280, height: 800,
    webPreferences: { preload: path.join(__dirname, 'preload.js') }
  });

  const url = process.env.VITE_URL || `file://${path.join(__dirname, '../web-dist/index.html')}`;
  win.loadURL(url);

  // Kiosk/anti-cheat toggles (enable for exam mode)
  // win.setKiosk(true);
  // globalShortcut.register('Alt+Tab', () => {}); // limited effect
  // session.defaultSession.setPermissionCheckHandler(() => false);

  // Prevent opening new windows
  win.webContents.setWindowOpenHandler(() => ({ action: 'deny' }));
}

app.whenReady().then(createWindow);
app.on('window-all-closed', () => { if (process.platform !== 'darwin') app.quit(); });
```

`apps/desktop/preload.js`

```js
const { contextBridge, desktopCapturer, ipcRenderer } = require('electron');
contextBridge.exposeInMainWorld('electronAPI', {
  // expose any exam-mode APIs (monitor count, screenshots) in future
});
```

**Build for desktop:**

1. Build web: `pnpm build:web` (outputs `apps/web/dist`)
2. Copy/point to `apps/desktop/web-dist` (symlink or script)
3. `pnpm -C apps/desktop build`

> For dev, run `pnpm dev:web` then `pnpm -C apps/desktop dev` (it loads localhost URL).

---

## 7) Routing (Frontend)

* `/login`, `/register`
* `/t/dashboard` (teacher)

  * create assignment (title, mode, questions\[n].text, answerKey)
  * show assignment code
  * view submissions
* `/s/dashboard` (student)

  * enter code → load questions → answer → submit

---

## 8) API Contract (copy to README for the agent)

**Auth**

* `POST /auth/register` `{ name,email,password,role }` → `{ id }`
* `POST /auth/login` `{ email,password }` → cookie `token`
* `POST /auth/logout` → `{ ok: true }`

**Assignments**

* `POST /assignments` (teacher) `{ title, mode, questions:[{id,text,answerKey}] }` → `{ id, code }`
* `GET /assignments/code/:code` (authed) → `Assignment`

**Submissions**

* `POST /submissions` (student) `{ assignmentCode, answers:[{questionId,text,sttMeta?}] }` → `{ submissionId, scores:[{questionId, similarity, awarded}], totalAwarded }`

---

## 9) Security & Privacy Defaults

* Use **httpOnly cookie** for JWT (already implemented).
* **CORS** allow only configured origin.
* **No audio uploads** in web mode (privacy); only text transcript sent.
* Add **data retention** policy (submissions kept; proctoring metadata optional, auto-purge after X days).
* Provide **“Delete my data”** endpoint later.

---

## 10) Anti-Cheat Strategy (phased)

* **Web (MVP):** disable copy/cut/paste/selection, blur logging, full-screen hint to teacher, show “recorded” badge when STT on.
* **Web (optional):** speech energy check (flag if multiple speakers detected—basic).
* **Electron (exam mode):** kiosk mode, prevent new windows, detect multiple monitors (future), periodic webcam snapshot (opt-in).

---

## 11) Testing Checklist (acceptance)

* Register/login works; cookies set.
* Teacher creates assignment; receives **unique code**.
* Student enters code; questions load.
* STT live transcript updates; manual edits allowed.
* Submit returns **per-question similarity (0..1)** and **totalAwarded**.
* Similar answer → similarity > 0.7 → award mark; unrelated → 0.
* Basic anti-cheat: right-click, copy/paste blocked; tab switch logged.
* PWA installs and loads offline shell (at least the UI).
* Electron dev build loads web URL; prod build loads packaged files.

---

## 12) Replit-Specific Instructions

1. Create a **Monorepo** project.
2. Set **separate Nix/Run commands** or use root scripts:

   * Dev API: `pnpm dev:api` (port 4000)
   * Dev Web: `pnpm dev:web` (port 5173)
3. In **Web `.env`**, set `VITE_API_URL=https://<replit-api-url>` when deployed.
4. Expose API port publicly; web calls must use that URL with `withCredentials: true`.
5. For Electron builds, run locally or on a VM (Replit won’t ship installers). Keep Electron folder ready for CI builds.

---

## 13) Optional Enhancements (backlog)

* Teacher-configurable **threshold** per assignment/question.
* Weighted scoring per question.
* **Language selector** for STT locale.
* **Glossary boosting**: pre-append teacher keywords to the answerKey for better semantic alignment.
* **Teacher review screen** to override scores.
* Export **CSV** of submissions.
* Institution mode: orgs, class rosters, bulk codes.

---

## 14) Commands Summary (copy/paste)

```bash
# Root
pnpm install

# Backend
pnpm -C packages/api dev           # local API at :4000
pnpm -C packages/api build && pnpm -C packages/api start

# Frontend
pnpm -C apps/web dev               # Vite dev at :5173
pnpm -C apps/web build             # outputs apps/web/dist

# Desktop
pnpm -C apps/desktop dev           # loads http://localhost:5173
pnpm -C apps/desktop build         # produces installers (when web build is packaged)
```

---

## 15) What the Agent Must Output (Deliverables)

* Working **API** with endpoints above.
* Working **Web UI** with:

  * Auth, Teacher Create, Student Answer, Submit & Score.
  * Client-side STT and edit-before-submit flow.
  * Basic anti-cheat installed on answer page.
* **PWA** installable.
* **Electron** wrapper that loads local build (prod) or localhost (dev).
* README with:

  * env setup
  * run/build commands
  * ports
  * feature overview
  * known limitations

---
---
---
---
---
# Additional IMP Note !!!

Nice — I’ll give you a single, copy-pasteable **additional prompt** (ready to attach to your Replit AI agent) that updates the previous guide with everything you asked for:

* Single app with **two-role login** (teachers + students)
* **Google OAuth** + strong JWT/httpOnly cookie auth + role in token
* Use **JS for server**, **TypeScript for client** (web + electron) as you requested
* **Separate server** (yes) — same API used by both web and electron clients
* Assignment schema extended with faculty/college/subject/start/end date and auto-delete logic
* Auto-delete / expiration policy (MongoDB TTL + fallback cron job)
* Electron build recommendation + short note about Electron Forge vs electron-builder and an optional Electron Forge config

Paste the following into your Replit agent as an extra instruction file or attach with the original doc.

---

## ➤ Additional Prompt for Replit AI Agent (copy-paste)

````
ADDITIONAL REQUIREMENTS — APPLY TO THE EXISTING MONOREPO (digital-assignment)

Make the following additions and changes to the repository and developer guide already provided:

1) AUTHENTICATION & LOGIN (Teachers + Students in one app)
- Single auth system used by both roles. Login/register endpoints accept { email, password } (and role at registration).
- On login, API returns an httpOnly cookie containing a JWT. JWT payload must include:
  { id: <userId>, role: 'teacher'|'student', email: <email> }.
- Protect routes with middleware that verifies JWT and sets req.user.

- UI:
  - Single login page that either:
    - Accepts credentials and the backend resolves role from DB; OR
    - Allows user to pick role during registration only.
  - Teacher-only routes are gated on token role === 'teacher'.

2) GOOGLE OAUTH 2.0 (Sign-in with Google)
- Implement Google OAuth on the backend using `passport` + `passport-google-oauth20` OR `google-auth-library` + manual token verification. Steps:
  - Add env vars:
    - GOOGLE_CLIENT_ID
    - GOOGLE_CLIENT_SECRET
    - GOOGLE_OAUTH_CALLBACK_URL (e.g. https://api.example.com/auth/google/callback or http://localhost:4000/auth/google/callback)
  - Endpoint flow:
    - `GET /auth/google` → redirect to google consent with scope `profile email`.
    - `GET /auth/google/callback` → handle callback, find or create user in DB (if new user set role default to 'student' unless teacher invite code provided), then create JWT and set httpOnly cookie and redirect to frontend route.
  - Save user `email`, `name`, and `googleId`. If user previously registered with password, link accounts by email (if verified by user).
- Frontend: Add a “Sign in with Google” button that opens the `/auth/google` endpoint.

3) SERVER LANGUAGE: JavaScript (Node.js) — CLIENT: TypeScript
- Convert backend API package to plain JavaScript (ES2019/Node 18+), using CommonJS or ES Modules as preferred on Replit.
- Keep frontend (apps/web) and Electron wrapper code in TypeScript (existing setup).
- Update `packages/api/package.json` scripts accordingly:
  - `dev`: `node-dev` or `nodemon` to run `src/index.js`.
  - Use `express`, `mongoose`, `passport`, `passport-google-oauth20`, `bcrypt`, `jsonwebtoken`, `cookie-parser`, `cors`.

4) ASSIGNMENT SCHEMA EXTENSIONS
- Extend the Assignment model with these fields (Mongo schema):
  - `facultyName: String`
  - `collegeName: String`
  - `subjectName: String`
  - `subjectCode: String`
  - `startDate: Date`
  - `endDate: Date`
  - `expireAt: Date` (for TTL deletion; set equal to endDate or endDate + retentionDays)
  - `autoDelete: Boolean` (if true, assignment will be removed automatically at expireAt)
  - `attributes: Mixed` (free-form map for future fields)
- Ensure `code` remains unique.

5) ENFORCE START/END DATE BEHAVIOR
- On submission endpoint (`POST /submissions`), check:
  - now < assignment.startDate → respond 403 "assignment_not_started"
  - now > assignment.endDate → respond 403 "assignment_closed"
- Teachers can still view past submissions even after endDate; auto-delete controlled by autoDelete and expireAt.

6) AUTO-DELETE / RETENTION STRATEGY
- Primary approach: Create a **MongoDB TTL index** on `expireAt`:
  - `db.assignments.createIndex({ expireAt: 1 }, { expireAfterSeconds: 0 })`
  - Set `expireAt = endDate` or `endDate + retentionDays` (if you want keep data few days)
- Fallback approach: Use a scheduled job (node-cron) that runs daily:
  - Query `assignments` where `expireAt <= now` and `autoDelete === true` and call removal function that:
    - either delete assignment document and associated submissions OR
    - soft-delete by setting `deleted: true` and preserve for admin review.
- Add `.env` variables:
  - `AUTO_DELETE_RETENTION_DAYS` (integer)
  - `USE_CRON_FALLBACK` (true/false)

7) ADDITIONAL ENV VARIABLES (add to `.env.example`)
- GOOGLE_CLIENT_ID=
- GOOGLE_CLIENT_SECRET=
- GOOGLE_OAUTH_CALLBACK_URL=
- AUTO_DELETE_RETENTION_DAYS=0
- USE_CRON_FALLBACK=true

8) AUTH SECURITY IMPROVEMENTS
- Use `httpOnly`, `sameSite: 'lax'` cookies for JWT.
- Store JWT secret in `JWT_SECRET` env var.
- Token expiry: use `JWT_EXPIRES` (e.g., '7d').
- Implement logout endpoint that clears cookie.
- Rate-limit auth endpoints (optional) — add `express-rate-limit`.

9) ROLE ASSIGNMENT / TEACHER INVITES
- To prevent students creating teacher accounts freely:
  - Option A: Use an admin flow where only admin can create teacher accounts.
  - Option B: Require a teacher invite code at registration. Invite codes are generated by admin/teacher and tied to an email/domain.
- Implement at least one of these — default to teacher accounts created by admin or via invite.

10) ELECTRON BUILD TOOL: electron-builder vs Electron Forge
- Recommendation: **electron-builder** is battle-tested and used earlier in the main guide. Continue to use `electron-builder`.
- If you prefer **Electron Forge**, it also works and automates packaging; here is an optional minimal Forge config to add if requested:
  - Add dev dep: `@electron-forge/cli`
  - Initialize: `npx @electron-forge/cli import`
  - Forge config lives in `package.json` under `"config.forge"`.
- For Replit agent: keep `electron-builder` as default — implement Forge only if asked.

11) DOCUMENTATION CHANGES & API CONTRACT
- Update README to include:
  - Google OAuth setup steps (create credentials in Google Cloud Console, set authorized redirect URIs).
  - How to set retention and TTL index.
  - How to generate teacher invite codes (if applicable).
  - How to enable/use cron fallback.

12) DB MIGRATION / INDEX CREATION
- On server startup, ensure TTL index exists:
  - `AssignmentModel.collection.createIndex({ expireAt: 1 }, { expireAfterSeconds: 0 })`
- Also create any necessary indices for efficient lookups (e.g., `code`, `teacherId`).

13) FRONTEND CHANGES (TypeScript)
- Login flow:
  - Add `Sign in with Google` button which calls backend `/auth/google`.
  - After OAuth redirect, backend should redirect to the frontend with a safe route like `/auth/success`. Frontend then fetches `/auth/me` to confirm token and user role.
- Assignment creation form:
  - Add fields for `facultyName`, `collegeName`, `subjectName`, `subjectCode`, `startDate`, `endDate`, `autoDelete`, and arbitrary `attributes`.
- Student submission UI:
  - Disable Submit button until `startDate` ≤ now ≤ `endDate`. If outside window, show informative message.
- Teacher dashboard:
  - Show assignment `startDate`, `endDate`, `expireAt`, and `autoDelete` status. Allow teacher to edit (before start) or extend end date.

14) BACKEND ROUTE EXAMPLES (JS snippets — put into packages/api/src)
- Create assignment route (simplified):
```js
// POST /assignments (teacher)
const now = new Date();
const { title, questions, startDate, endDate, autoDelete, facultyName, collegeName, subjectName, subjectCode } = req.body;
const expireAt = endDate ? new Date(new Date(endDate).getTime() + (RETENTION_DAYS * 24*60*60*1000)) : null;
const assignment = await Assignment.create({
  code: genCode(),
  title, questions, mode, teacherId: req.user.id,
  facultyName, collegeName, subjectName, subjectCode,
  startDate: new Date(startDate), endDate: new Date(endDate),
  autoDelete: !!autoDelete, expireAt
});
res.json({ id: assignment._id, code: assignment.code });
````

* Submission route:

```js
// POST /submissions
const assignment = await Assignment.findOne({ code: assignmentCode });
if (!assignment) return res.status(404).send({ error: 'assignment_not_found' });
const now = new Date();
if (assignment.startDate && now < assignment.startDate) return res.status(403).send({ error: 'assignment_not_started' });
if (assignment.endDate && now > assignment.endDate) return res.status(403).send({ error: 'assignment_closed' });
// proceed to grade...
```

15. CLEANUP / DELETE JOB (cron fallback)

* Use `node-cron` or `agenda` or a small daily job:

```js
const cron = require('node-cron');
cron.schedule('0 0 * * *', async () => {
  const toDelete = await Assignment.find({ expireAt: { $lte: new Date() }, autoDelete: true });
  for (const a of toDelete) {
    await Submission.deleteMany({ assignmentId: a._id });
    await Assignment.deleteOne({ _id: a._id });
    // optionally log deletion
  }
});
```

16. TESTS

* Add tests for:

  * Google OAuth happy path (mock).
  * Role enforcement on teacher-only routes.
  * start/end date enforcement on submissions.
  * TTL index behavior (set expireAt to a near-future date during test then assert deletion).

17. DELIVERABLES (what the agent must produce)

* Updated README with OAuth instructions + TTL/cron docs
* Backend (JS) code implementing OAuth, role-based auth, TTL creation, cron fallback
* Updated Assignment schema & submission checks
* Frontend (TS) changes for Google OAuth button, assignment fields, and client-side start/end enforcement
* Optional: small admin UI to generate teacher invite codes (recommended)
* Note on Electron Forge vs electron-builder and continuation with electron-builder by default

END OF ADDITIONAL PROMPT

```

---

If you want, I’ll also:
- Produce the **exact code files** to drop into `packages/api/src` (JS) for Google OAuth and TTL index creation, and the updated Assignment model.  
- Or generate a **smaller patch** that the Replit agent can apply automatically.

Which do you prefer — paste the additional prompt as-is to the agent, or should I generate the actual JS files (auth/google, cron job, schema) ready to be committed?
```
